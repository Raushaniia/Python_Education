# авайте сначала поймем, что обеспечивает Python GIL:
#
# Любая операция/инструкция выполняется в интерпретаторе. GIL гарантирует,
# что переводчик удерживается одним потоком в определенный момент времени.
# А ваша программа на Python с несколькими потоками работает в одном интерпретаторе.
#  В любой конкретный момент времени этот переводчик удерживается одним потоком.
# Это означает, что в любой момент времени работает только тот поток, который содержит интерпретатор.
#
# Теперь, почему это проблема:
#
# Ваша машина может иметь несколько ядер/процессоров. И несколько ядер позволяют выполнять несколько потоков одновременно,
# т.е. несколько потоков могут выполняться в любой конкретный момент времени. , Но поскольку интерпретатор удерживается одним
# потоком, другие потоки ничего не делают, даже если у них есть доступ к ядру. Таким образом, вы не получаете никаких преимуществ,
# предоставляемых несколькими ядрами, поскольку в любой момент используется только одно ядро, то есть ядро, используемое потоком,
#  который в настоящее время содержит интерпретатор. Таким образом, ваша программа будет выполняться так же долго, как если бы это
# была однопоточная программа.
#
# Однако потенциально блокирующие или длительные операции, такие как ввод-вывод, обработка изображений и сокращение
#  числа NumPy, происходят вне GIL. Взято отсюда. Таким образом, для таких операций многопоточная операция все равно будет
#  быстрее однопоточной, несмотря на наличие GIL. Таким образом, GIL не всегда является узким местом.
#
# Изменение: GIL является деталью реализации CPython. IronPython и Jython не имеют GIL, поэтому в них должна
# быть по-настоящему многопоточная программа, хотя я никогда не использовал PyPy и Jython и не уверен в этом.